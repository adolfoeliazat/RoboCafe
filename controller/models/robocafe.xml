<?xml version="1.0" standalone="no"?>
<!DOCTYPE entity PUBLIC "-//UC Berkeley//DTD MoML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/MoML_1.dtd">
<entity name="robocafe" class="ptolemy.actor.TypedCompositeActor">
    <property name="_createdBy" class="ptolemy.kernel.attributes.VersionAttribute" value="11.0.devel">
    </property>
    <property name="DE Director" class="ptolemy.domains.de.kernel.DEDirector">
        <property name="synchronizeToRealTime" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[1345.0, 995.0]">
        </property>
    </property>
    <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={64, -4, 2497, 1445}, maximized=true}">
    </property>
    <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[2281, 1327]">
    </property>
    <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="1.1305996784770789">
    </property>
    <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{914.4674140573059, 833.0255421349501}">
    </property>
    <property name="_layoutConfiguration" class="ptolemy.vergil.basic.layout.LayoutConfiguration">
    </property>
    <property name="ModelID" class="ptolemy.vergil.kernel.attributes.IDAttribute">
        <property name="created" class="ptolemy.kernel.util.StringAttribute" value="Aug 12, 2015 4:54:58 PM">
        </property>
        <property name="lastUpdated" class="ptolemy.kernel.util.StringAttribute" value="Sep 15, 2015 3:11:51 PM">
        </property>
        <property name="author" class="ptolemy.kernel.util.StringAttribute" value="bradjc">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[1335.0, 1175.0]">
        </property>
    </property>
    <property name="_hideName" class="ptolemy.data.expr.SingletonParameter" value="false">
    </property>
    <property name="Annotation6" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textSize" class="ptolemy.data.expr.Parameter" value="14">
        </property>
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.8,0.0,0.0,1.0}">
        </property>
        <property name="anchor" class="ptolemy.data.expr.StringParameter" value="south">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Choice Receiver">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[480.0, 1030.0]">
        </property>
    </property>
    <property name="Annotation7" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textSize" class="ptolemy.data.expr.Parameter" value="18">
        </property>
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.8,0.0,0.0,1.0}">
        </property>
        <property name="anchor" class="ptolemy.data.expr.StringParameter" value="south">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Main Controller">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[675.0, 965.0]">
        </property>
    </property>
    <property name="rosBridgeIP" class="ptolemy.data.expr.StringParameter" value="192.168.11.108">
        <property name="_hideName" class="ptolemy.kernel.util.SingletonAttribute">
        </property>
        <property name="_icon" class="ptolemy.vergil.icon.ValueIcon">
            <property name="_color" class="ptolemy.actor.gui.ColorAttribute" value="{1.0, 0.0, 0.0, 1.0}">
            </property>
        </property>
        <property name="_smallIconDescription" class="ptolemy.kernel.util.SingletonConfigurableAttribute">
            <configure>
      <svg>
        <text x="20" style="font-size:14; font-family:SansSerif; fill:red" y="20">-S-</text>
      </svg>
    </configure>
        </property>
        <property name="_editorFactory" class="ptolemy.vergil.toolbox.VisibleParameterEditorFactory">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[1140.0, 1040.0]">
        </property>
    </property>
    <property name="poseUpdateThreshold" class="ptolemy.data.expr.Parameter" value="0.3">
        <property name="_hideName" class="ptolemy.kernel.util.SingletonAttribute">
        </property>
        <property name="_icon" class="ptolemy.vergil.icon.ValueIcon">
            <property name="_color" class="ptolemy.actor.gui.ColorAttribute" value="{0.0, 0.0, 1.0, 1.0}">
            </property>
        </property>
        <property name="_smallIconDescription" class="ptolemy.kernel.util.SingletonConfigurableAttribute">
            <configure>
      <svg>
        <text x="20" style="font-size:14; font-family:SansSerif; fill:blue" y="20">-P-</text>
      </svg>
    </configure>
        </property>
        <property name="_editorFactory" class="ptolemy.vergil.toolbox.VisibleParameterEditorFactory">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[1140.0, 1060.0]">
        </property>
    </property>
    <property name="spinDuration" class="ptolemy.data.expr.Parameter" value="7">
        <property name="_hideName" class="ptolemy.kernel.util.SingletonAttribute">
        </property>
        <property name="_icon" class="ptolemy.vergil.icon.ValueIcon">
            <property name="_color" class="ptolemy.actor.gui.ColorAttribute" value="{0.0, 0.0, 1.0, 1.0}">
            </property>
        </property>
        <property name="_smallIconDescription" class="ptolemy.kernel.util.SingletonConfigurableAttribute">
            <configure>
      <svg>
        <text x="20" style="font-size:14; font-family:SansSerif; fill:blue" y="20">-P-</text>
      </svg>
    </configure>
        </property>
        <property name="_editorFactory" class="ptolemy.vergil.toolbox.VisibleParameterEditorFactory">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[1140.0, 1080.0]">
        </property>
    </property>
    <property name="enableBackwardTypeInference" class="ptolemy.data.expr.Parameter" value="false">
    </property>
    <property name="_defaultInferredWidthTo1" class="ptolemy.data.expr.Parameter" value="true">
    </property>
    <property name="Rectangle3" class="ptolemy.vergil.kernel.attributes.RectangleAttribute">
        <property name="_location" class="ptolemy.kernel.util.Location" value="667.4997281426706, 1133.3336150076052">
        </property>
        <property name="lineWidth" class="ptolemy.data.expr.Parameter" value="2.0">
        </property>
        <property name="lineColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.6,0.6,0.6,1.0}">
        </property>
        <property name="width" class="ptolemy.data.expr.Parameter" value="604.9342105263156">
        </property>
        <property name="height" class="ptolemy.data.expr.Parameter" value="323.2786885245903">
        </property>
        <property name="centered" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="fillColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.8,0.0,0.0,0.15}">
        </property>
        <property name="rounding" class="ptolemy.data.expr.Parameter" value="25">
        </property>
        <property name="_renderFirst" class="ptolemy.kernel.util.SingletonAttribute">
        </property>
    </property>
    <property name="Annotation8" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textSize" class="ptolemy.data.expr.Parameter" value="14">
        </property>
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.8,0.0,0.0,1.0}">
        </property>
        <property name="anchor" class="ptolemy.data.expr.StringParameter" value="south">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Applause Detection">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[470.0, 1190.0]">
        </property>
    </property>
    <entity name="WebSocketServer" class="org.terraswarm.accessor.JSAccessor">
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor starts a server that listens for web socket&#10; *  connection requests on the specified hostInterface and port.  The&#10; *  hostInterface is needed only if the host machine has more than one&#10; *  network interface (e.g. Ethernet and WiFi) and 'localhost' does&#10; *  not resolve to the desired interface.&#10; *&#10; *  &lt;p&gt;The output &lt;code&gt;connection&lt;/code&gt; reports the when a&#10; *  connection is opened or closed.&lt;/p&gt;&#10; *&#10; *  &lt;p&gt;When a message arrives on a connection, a &lt;code&gt;received&lt;/code&gt;&#10; *  output is produced with that message.&lt;/p&gt;&#10; *&#10; *  &lt;p&gt;When an input arrives on &lt;code&gt;toSend&lt;/code&gt;, then a message is&#10; *  sent to one or all of the open socket connections.&lt;/p&gt;&#10; *&#10; *  &lt;p&gt;When &lt;code&gt;wrapup()&lt;/code&gt; is invoked, this accessor closes the&#10; *  server and all connections.&lt;/p&gt;&#10; *&#10; *  &lt;p&gt;The messages can be any type that has a JSON representation.&#10; *  For incomming messages, this accessor assumes that the message is&#10; *  a string in UTF-8 that encodes a JSON object.&lt;/p&gt;&#10; *&#10; *  &lt;p&gt;This accessor requires the module webSocket.&lt;/p&gt;&#10; *&#10; *  @accessor WebSocketServer&#10; *  @parameter {string} hostInterface The IP address or domain name of the&#10; *    network interface to listen to.&#10; *  @parameter {number} port The port to listen to for connections.&#10; *  @input toSend The data to be sent to open sockets. If this is an object with 'socketID' field and a 'message' field, then send the value of the message field to the socket identified by the socketID field. If the input has any other form, then the message is broadcast to all open socket connections.&#10; *  @output connection An output produced when a connection opens or closes. The output is an object with two fields, a 'socketID', which is a unique ID for this client connection, and a 'status' field, which is the string 'open' or 'closed'.&#10; *  @output received A message received a client in the form of an object with two fields, a 'socketID', which is a unique ID for this client connection, and a 'message' field, which is the message received from the client.&#10; *  @author Hokeun Kim, Edward Lee &#10; *  @version $$Id: WebSocketServer.js 234 2015-08-01 22:06:40Z eal $$ &#10; */&#10;&#10;var WebSocket = require('webSocket');&#10;var server = null;&#10;var running = false;&#10;&#10;/** Sets up the accessor by defining inputs and outputs. */&#10;exports.setup = function() {&#10;    parameter('hostInterface', {&#10;        value: &quot;localhost&quot;, &#10;        type: &quot;string&quot; &#10;    });&#10;    parameter('port', {&#10;        value: 8080, &#10;        type: &quot;int&quot; &#10;    });&#10;    input('toSend');&#10;    output('received');&#10;    output('connection');&#10;}&#10;&#10;var handle;&#10;var sockets = [];&#10;&#10;/** Starts the web socket and attaches functions to inputs and outputs. &#10;  * Adds an input handler on toSend that sends the input received to the right socket. */ &#10;exports.initialize = function() {&#10;    if (!server) {&#10;        server = new WebSocket.Server({'port':getParameter('port'),&#10;                                       'hostInterface':getParameter('hostInterface')});&#10;        server.on('listening', onListening);&#10;        server.on('connection', onConnection);&#10;        server.start();&#10;    }&#10;    running = true;&#10;&#10;    handle = addInputHandler('toSend', function() {&#10;        var data = get('toSend');&#10;        // Careful: Don't do if (data) because if data === 0, then data is false.&#10;        if (data !== null) {&#10;            if ((data.socketID != null)  &amp;&amp; (data.message != null)) {&#10;                // data has the right form for a point-to-point send.&#10;                if (sockets[data.socketID] &amp;&amp; sockets[data.socketID].isOpen()) {&#10;                    // id matches this socket.&#10;                    console.log(&quot;Sending to socket id &quot; &#10;                            + data.socketID&#10;                            + &quot; message: &quot;&#10;                            + data.message);&#10;                    sockets[data.socketID].send(data.message);&#10;                } else {&#10;                    console.log('Socket with ID ' + data.socketID&#10;                            + ' is not open. Discarding message: ' + data.message);&#10;                }&#10;            } else {&#10;                // No socketID or message, so this is a broadcast message.&#10;                var success = false;&#10;                for (var id = 0; id &lt; sockets.length; id++) {&#10;                    if (sockets[id].isOpen()) {&#10;                        console.log(&quot;Broadcasting to socket id &quot; + id &#10;                                + &quot; message: &quot; + data);&#10;                        sockets[id].send(data);&#10;                        success = true;&#10;                    }&#10;                }&#10;                if (!success) {&#10;                    console.log('No open sockets. Discarding message: ' + data.message);&#10;                }&#10;            }&#10;        }&#10;    });&#10;}&#10;&#10;function onListening() {&#10;    console.log('Server: Listening for socket connection requests.');&#10;}&#10;&#10;/** Executes when a connection has been establised.&lt;br&gt;&#10; *  Triggers an output on &lt;code&gt;'connection'&lt;/code&gt;.&#10; *  Adds an event listener to the socket. */&#10;function onConnection(socket) {&#10;   //socketID is the index of the socket in the sockets array. &#10;    var socketID = sockets.length;&#10;    console.log('Server: new socket established with ID: ' + socketID);&#10;    send('connection', {'socketID':socketID, 'status':'open'});&#10;    socket.on('message', function(message) {&#10;        send('received', {'socketID':socketID, 'message':message});&#10;    });&#10;    socket.on('close', function(message) {&#10;        send('connection', {'socketID':socketID, 'status':'closed'});&#10;    });&#10;&#10;    sockets.push(socket);    &#10;}&#10;&#10;/** Removes all inputHandlers from sockets.&lt;br&gt;&#10; * Unregisters event listeners from sockets.&lt;br&gt;&#10; * Closes server. */&#10;exports.wrapup = function(){&#10;    for (var i = 0; i &lt; sockets.length; i++) {&#10;        sockets[i].removeAllListeners();&#10;    }&#10;&#10;    sockets = [];&#10;    removeInputHandler(handle); &#10;&#10;    if (server != null) {&#10;        server.removeAllListeners();&#10;        server.close();&#10;        server = null;&#10;    }&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="http://terraswarm.org/accessors/net/WebSocketServer.js">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="JSAccessorIcon" class="ptolemy.vergil.icon.EditorIcon">
            <property name="rectangle" class="ptolemy.vergil.kernel.attributes.RectangleAttribute">
                <property name="_location" class="ptolemy.kernel.util.Location" value="[-36.0, -29.0]">
                </property>
                <property name="width" class="ptolemy.data.expr.Parameter" value="74.0">
                </property>
                <property name="height" class="ptolemy.data.expr.Parameter" value="64.0">
                </property>
                <property name="fillColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.6,0.8,1.0,1.0}">
                </property>
            </property>
            <property name="Annotation" class="ptolemy.vergil.kernel.attributes.TextAttribute">
                <property name="textSize" class="ptolemy.data.expr.Parameter" value="30">
                </property>
                <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0,0.0,0.0,1.0}">
                </property>
                <property name="bold" class="ptolemy.data.expr.Parameter" value="false">
                </property>
                <property name="italic" class="ptolemy.data.expr.Parameter" value="false">
                </property>
                <property name="text" class="ptolemy.kernel.util.StringAttribute" value="WS">
                </property>
                <property name="_location" class="ptolemy.kernel.util.Location" value="[-16.0, -12.0]">
                </property>
            </property>
            <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={348, 412, 934, 634}, maximized=false}">
            </property>
            <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[700, 524]">
            </property>
            <property name="polygon" class="ptolemy.vergil.kernel.attributes.ResizablePolygonAttribute">
                <property name="_location" class="ptolemy.kernel.util.Location" value="{-25.0, 3.0}">
                </property>
                <property name="lineWidth" class="ptolemy.data.expr.Parameter" value="0">
                </property>
                <property name="width" class="ptolemy.data.expr.Parameter" value="14.0">
                </property>
                <property name="height" class="ptolemy.data.expr.Parameter" value="60.99999999999999">
                </property>
                <property name="centered" class="ptolemy.data.expr.Parameter" value="true">
                </property>
                <property name="fillColor" class="ptolemy.actor.gui.ColorAttribute" value="{1.0, 1.0, 1.0, 1.0}">
                </property>
                <property name="vertices" class="ptolemy.data.expr.Parameter" value="{0.0, 0.0, 10.0, -10.0, 0.0, -20.0}">
                </property>
                <property name="_renderLast" class="ptolemy.kernel.util.SingletonAttribute">
                </property>
            </property>
            <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="4.0">
            </property>
            <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{0.0, 0.0}">
            </property>
        </property>
        <property name="hostInterface" class="ptolemy.data.expr.Parameter" value="0.0.0.0">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="8081">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[475.0, 1085.0]">
        </property>
        <port name="error" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="false">
            </property>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="connection" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="RoboCafeController" class="org.terraswarm.accessor.JSAccessor">
        <display name="ApplicationController"/>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of Michigan&#10;&#10;/** RoboCafe Controller&#10; *&#10; *  @accessor RoboCafeController&#10; *&#10;*/&#10;&#10;&#10;var NUM_ROBOTS = 4;&#10;&#10;// STATES&#10;var STATE_IDLE = 'IDLE';         // Robot is currently just sitting there.&#10;var STATE_SERVING = 'SERVING';   // Robot has been requested and is going to a person.&#10;var STATE_SPINNING = 'SPINNING'; // Applause was detected and the robot is interrupted to spin.&#10;&#10;// MAPPING OF ITEM TO ROBOTS and the queue for that item&#10;var ITEMS = {&#10;  Twix:        {&#10;    robots: [0, 3],&#10;    queue: []&#10;  },&#10;  SquirtGun:   {&#10;    robots: [1],&#10;    queue: []&#10;  },&#10;  BouncyBalls: {&#10;    robots: [2],&#10;    queue: []&#10;  }&#10;}&#10;&#10;// Array of robot structs with state on each one.&#10;var robots = [];&#10;&#10;&#10;/** Define inputs and outputs. */&#10;exports.setup = function () {&#10;  //&#10;  // I/O&#10;  //&#10;  input('UserChoice');&#10;  input('Applause');&#10;&#10;  output('SelectPhoneRobot');&#10;  output('RobotStatus');&#10;  output('AppState');&#10;&#10;  //&#10;  // Parameters&#10;  //&#10;  // Which robot to make spin.&#10;  parameter('SpinRobotIndex', {&#10;    type: 'number',&#10;    value: 0&#10;  });&#10;  // Number of seconds the robot will spin for.&#10;  parameter('SpinRobotDuration', {&#10;    type: 'number',&#10;    value: 5&#10;  });&#10;}&#10;&#10;exports.initialize = function () {&#10;&#10;  // Initialize all robots&#10;  for (var i=0; i&lt;NUM_ROBOTS; i++) {&#10;    var robot = {};&#10;    robot.state = STATE_IDLE;&#10;    robot.servicing = null;&#10;    robots[i] = robot;&#10;&#10;    // Output initial status&#10;    update_status(i, STATE_IDLE);&#10;  }&#10;&#10;  addInputHandler('UserChoice', Choice_in);&#10;  addInputHandler('Applause', Applause_in);&#10;&#10;  // in case more than one request is received before a 'spin','cancelled' or&#10;  // 'finished' event, the second request ends up in the queue until the next&#10;  // event. To avoid this, poll queues and process events if robots are free.&#10;  setInterval(process_queue, 1000);&#10;}&#10;&#10;&#10;// Effectively connect an incoming location stream to a robot's&#10;// /goal topic.&#10;// operation is whether to connect ('add') or disconnect ('remove')&#10;// the connection between the phone and robot.&#10;function set_source_and_robot (phone_id, robot_index, operation) {&#10;  var out = {&#10;    type: operation,&#10;    input: phone_id,&#10;    output: robot_index&#10;  }&#10;  send('SelectPhoneRobot', out);&#10;}&#10;&#10;// Publish on the status output a robot's state change&#10;function update_status (robot_index, state) {&#10;  robots[robot_index].state = state;&#10;  send('RobotStatus', {&#10;    robotid: robot_index,&#10;    status: state&#10;  });&#10;}&#10;&#10;// Tell all listeners what's going on in the controller.&#10;function publish_state () {&#10;  send('AppState', {robots: robots, items: ITEMS});&#10;}&#10;&#10;function process_queue () {&#10;&#10;  // Iterate over items, and in turn each robot&#10;  for (var item in ITEMS) {&#10;    var item_obj = ITEMS[item];&#10;&#10;    // Each robot for the item&#10;    for (var i=0; i&lt;item_obj.robots.length; i++) {&#10;      var rbt_idx = item_obj.robots[i];&#10;      var rbt = robots[rbt_idx];&#10;&#10;      // Our options are to send this robot to someone in the queue,&#10;      // leave it alone, or send it home.&#10;      if (rbt.state != STATE_IDLE) {&#10;        // Robot is busy, leave it alone&#10;        console.log('Robot ' + rbt_idx + ' is busy. Queue len: ' + item_obj.queue.length);&#10;&#10;      } else {&#10;        // Robot is idle.&#10;        if (item_obj.queue.length &gt; 0) {&#10;          // Aha! Someone is waiting for this item, and this robot is idle.&#10;          // Send it!&#10;          var next_phone = item_obj.queue.shift();&#10;          rbt.state = STATE_SERVING;&#10;          // Keep track of which user this robot is attached to&#10;          rbt.servicing = next_phone;&#10;          // And send the robot to the person&#10;          set_source_and_robot(next_phone, rbt_idx, 'add');&#10;          // And update output status&#10;          update_status(rbt_idx, STATE_SERVING);&#10;          publish_state();&#10;&#10;        } else {&#10;          // This robot is idle and no one wants anything from it.&#10;          // Make sure it is going home. It's entirely possible this line&#10;          // of code gets called multiple times. This is OK as the switch&#10;          // handles that.&#10;          set_source_and_robot('Home'+rbt_idx, rbt_idx, 'add');&#10;        }&#10;      }&#10;    }&#10;  }&#10;}&#10;&#10;var Choice_in = function () {&#10;  var ws_payload = get('UserChoice');&#10;&#10;  // Check if this is a normal message from a client or a status message&#10;  if ('message' in ws_payload) {&#10;    var msg = ws_payload.message;&#10;&#10;    // Get the unique identifier for what sent this packet&#10;    var phone_id = msg.phone_id;&#10;&#10;    // Do some common operations for choice selections, cancellations,&#10;    // and done events&#10;    if (msg.type == 'selection' ||&#10;        msg.type == 'cancelled' ||&#10;        msg.type == 'finished') {&#10;&#10;      // What item/candy the user asked for&#10;      var selection = msg.selection;&#10;&#10;      // Now that we know what the user wants, figure out if we can satisfy&#10;      // the request&#10;      if (selection in ITEMS) {&#10;&#10;        // We know what this is. If the user wants it we add them to the queue&#10;        // and we'll process the queue to dispatch a robot.&#10;        if (msg.type == 'selection') {&#10;          // Add the request to the queue for that item, if the user is not&#10;          // already in the queue.&#10;          if (ITEMS[selection].queue.indexOf(phone_id) == -1) {&#10;            ITEMS[selection].queue.push(phone_id);&#10;            publish_state();&#10;          }&#10;&#10;        } else if (msg.type == 'cancelled' || msg.type == 'finished') {&#10;          // User got the item or doesn't want it&#10;&#10;          // Get the list of robots that may have been navigating to the user&#10;          var robot_indexes = ITEMS[selection].robots;&#10;&#10;          // Iterate each robot, checking to see if it was heading for that&#10;          // user. If so, stop the robot from doing that.&#10;          for (var i=0; i&lt;robot_indexes.length; i++) {&#10;            var rbt_idx = robot_indexes[i];&#10;            var rbt = robots[rbt_idx];&#10;&#10;            // Check if this robot was helping this person&#10;            if (rbt.state == STATE_SERVING &amp;&amp; rbt.servicing == phone_id) {&#10;              // This checks out. Stop the robot from what it was doing&#10;              // and send it home.&#10;              set_source_and_robot(phone_id, rbt_idx, 'remove');&#10;              update_status(rbt_idx, STATE_IDLE);&#10;              rbt.servicing = null;&#10;              publish_state();&#10;            }&#10;          }&#10;&#10;          // Now check that this user wasn't queued for a robot with that&#10;          // item. If it was, remove it.&#10;          var item_queue = ITEMS[selection].queue;&#10;          if (item_queue.indexOf(phone_id) &gt; -1) {&#10;            item_queue.splice(item_queue.indexOf(phone_id), 1);&#10;          }&#10;        }&#10;&#10;        // And take care of our queues to see if we should dispatch robots&#10;        // anywhere.&#10;        process_queue();&#10;&#10;      } else {&#10;        console.log('Could not find a robot that matched item ' + selection);&#10;      }&#10;&#10;    }&#10;&#10;  } else {&#10;    console.log('Not a valid web socket message');&#10;  }&#10;&#10;}&#10;&#10;var Applause_in = function () {&#10;  var a = get('Applause');&#10;&#10;  if (a == 'no_applause') {&#10;    // ignore&#10;&#10;  } else if (a == 'some_applause') {&#10;    // Make one robot spin&#10;&#10;    var robot_index = parseInt(getParameter('SpinRobotIndex'));&#10;    var robot = robots[robot_index];&#10;&#10;    //unset the service status.&#10;    // var old_servicing = robot.servicing;&#10;&#10;    // Robot is busy with spinning!&#10;    update_status(robot_index, STATE_SPINNING);&#10;&#10;    if (robot.servicing != null) {&#10;      console.log(&quot;Will queue &quot; + robot.servicing + &quot; to be processed later.&quot;);&#10;      // Find which item this robot is carrying, and add this user to that&#10;      // queue.&#10;      for (var item in ITEMS) {&#10;        if (ITEMS[item].robots.indexOf(robot_index) != -1) {&#10;          ITEMS[item].queue.unshift(robot.servicing);&#10;        }&#10;      }&#10;&#10;      // Stop what ever was controlling the robot before&#10;      set_source_and_robot(robot.servicing, robot_index, 'remove');&#10;&#10;      // Clear this&#10;      robot.servicing = null;&#10;    }&#10;&#10;    // Make it spin&#10;    set_source_and_robot('Spin', robot_index, 'add');&#10;&#10;    // After the spin is done, put it back&#10;    setTimeout(function () {&#10;      // Stop the spin command&#10;      set_source_and_robot('Spin', robot_index, 'remove');&#10;&#10;      // Go idle for now&#10;      update_status(robot_index, STATE_IDLE);&#10;&#10;      // Keep all of the update logic in one place. Since we added the previous&#10;      // user to the front of the queue we can just use that to reconfigure the&#10;      // robot.&#10;      process_queue();&#10;    }, getParameter('SpinRobotDuration') * 1000);&#10;&#10;&#10;  }&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="../accessors/RoboCafeController.js">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[695.0, 1095.0]">
        </property>
        <property name="SpinRobotIndex" class="ptolemy.data.expr.Parameter" value="2">
        </property>
        <property name="SpinRobotDuration" class="ptolemy.data.expr.Parameter" value="spinDuration">
        </property>
        <port name="error" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="UserChoice" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="SelectPhoneRobot" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="RobotStatus" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="Applause" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="AppState" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="Display7" class="ptolemy.actor.lib.gui.Display">
        <display name="User Choices"/>
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={837, 276, 761, 312}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[759, 262]">
        </property>
        <property name="title" class="ptolemy.data.expr.StringParameter" value="User Choices">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[650.0, 1015.0]">
        </property>
    </entity>
    <entity name="WebSocketServer4" class="org.terraswarm.accessor.JSAccessor">
        <display name="RobotStatusServer"/>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor starts a server that listens for web socket&#10; *  connection requests on the specified hostInterface and port.  The&#10; *  hostInterface is needed only if the host machine has more than one&#10; *  network interface (e.g. Ethernet and WiFi) and 'localhost' does&#10; *  not resolve to the desired interface.&#10; *&#10; *  The output `connection` reports the when a&#10; *  connection is opened or closed.&#10; *&#10; *  When a message arrives on a connection, a `received`&#10; *  output is produced with that message. The maxFrameSize parameter limits the size&#10; *  of received messages, and any attempt to send to this client a larger message&#10; *  will cause an error.&#10; *&#10; *  When an input arrives on `toSend`, then a message is&#10; *  sent to one or all of the open socket connections.&#10; *&#10; *  When `wrapup()` is invoked, this accessor closes the&#10; *  server and all connections.&#10; *&#10; *  The default type for both sending and receiving&#10; *  is 'application/json', which allows sending and receiving anything that has&#10; *  a string representation in JSON. The types supported by this implementation&#10; *  include at least:&#10; *  * __application/json__: The send() function uses JSON.stringify() and sends the&#10; *    result with a UTF-8 encoding. An incoming byte stream will be parsed as JSON,&#10; *    and if the parsing fails, will be provided as a string interpretation of the byte&#10; *    stream.&#10; *  * __text/\*__: Any text type is sent as a string encoded in UTF-8.&#10; *  * __image/x__: Where __x__ is one of __json__, __png__, __gif__,&#10; *    and more.&#10; *    In this case, the data passed to send() is assumed to be an image, as encoded&#10; *    on the host, and the image will be encoded as a byte stream in the specified&#10; *    format before sending.  A received byte stream will be decoded as an image,&#10; *    if possible.&#10; *&#10; *  This accessor requires the module webSocket.&#10; *&#10; *  @accessor net/WebSocketServer&#10; *  @parameter {string} hostInterface The IP address or domain name of the&#10; *    network interface to listen to.&#10; *  @parameter {int} port The port to listen to for connections.&#10; *  @parameter {string} receiveType The MIME type for incoming messages, which defaults to 'application/json'.&#10; *  @parameter {string} sendType The MIME type for outgoing messages, which defaults to 'application/json'.&#10; *  @parameter {int} maxFrameSize The maximum frame size for a received message (default is 65536).&#10; *  @input toSend The data to be sent to open sockets. If this is an object with 'socketID' field and a 'message' field, then send the value of the message field to the socket identified by the socketID field. If the input has any other form, then the message is broadcast to all open socket connections.&#10; *  @output connection An output produced when a connection opens or closes. The output is an object with two fields, a 'socketID', which is a unique ID for this client connection, and a 'status' field, which is the string 'open' or 'closed'.&#10; *  @output received A message received a client in the form of an object with two fields, a 'socketID', which is a unique ID for this client connection, and a 'message' field, which is the message received from the client.&#10; *  @author Hokeun Kim, Edward Lee &#10; *  @version $$Id: WebSocketServer.js 282 2015-08-28 19:04:40Z eal $$ &#10; */&#10;&#10;var WebSocket = require('webSocket');&#10;var server = null;&#10;var running = false;&#10;&#10;/** Sets up the accessor by defining inputs and outputs. */&#10;exports.setup = function() {&#10;    parameter('hostInterface', {&#10;        value: &quot;localhost&quot;, &#10;        type: &quot;string&quot; &#10;    });&#10;    parameter('port', {&#10;        value: 8080, &#10;        type: &quot;int&quot; &#10;    });&#10;    parameter('receiveType', {&#10;        type : 'string',&#10;        value : 'application/json'&#10;    });&#10;    parameter('sendType', {&#10;        type : 'string',&#10;        value : 'application/json'&#10;    });&#10;    parameter('maxFrameSize', {&#10;        value: 65536, &#10;        type: &quot;int&quot; &#10;    });&#10;    input('toSend');&#10;    output('received');&#10;    output('connection');&#10;}&#10;&#10;var handle;&#10;var sockets = [];&#10;&#10;/** Starts the web socket and attaches functions to inputs and outputs. &#10;  * Adds an input handler on toSend that sends the input received to the right socket. */ &#10;exports.initialize = function() {&#10;    if (!server) {&#10;        server = new WebSocket.Server({&#10;                'port':getParameter('port'),&#10;                'hostInterface':getParameter('hostInterface'),&#10;                'receiveType':getParameter('receiveType'),&#10;                'sendType':getParameter('sendType'),&#10;                'maxFrameSize':getParameter('maxFrameSize')&#10;        });&#10;        server.on('listening', onListening);&#10;        server.on('connection', onConnection);&#10;        server.on('error', function (message) {&#10;            error(message);&#10;        });&#10;        server.start();&#10;    }&#10;    running = true;&#10;&#10;    handle = addInputHandler('toSend', function() {&#10;        var data = get('toSend');&#10;        // Careful: Don't do if (data) because if data === 0, then data is false.&#10;        if (data !== null) {&#10;            if ((data.socketID != null)  &amp;&amp; (data.message != null)) {&#10;                // data has the right form for a point-to-point send.&#10;                if (sockets[data.socketID] &amp;&amp; sockets[data.socketID].isOpen()) {&#10;                    // id matches this socket.&#10;                    console.log(&quot;Sending to socket id &quot; &#10;                            + data.socketID&#10;                            + &quot; message: &quot;&#10;                            + data.message);&#10;                    sockets[data.socketID].send(data.message);&#10;                } else {&#10;                    console.log('Socket with ID ' + data.socketID&#10;                            + ' is not open. Discarding message: ' + data.message);&#10;                }&#10;            } else {&#10;                // No socketID or message, so this is a broadcast message.&#10;                var success = false;&#10;                for (var id = 0; id &lt; sockets.length; id++) {&#10;                    if (sockets[id].isOpen()) {&#10;                        console.log(&quot;Broadcasting to socket id &quot; + id &#10;                                + &quot; message: &quot; + data);&#10;                        sockets[id].send(data);&#10;                        success = true;&#10;                    }&#10;                }&#10;                if (!success) {&#10;                    console.log('No open sockets. Discarding message: ' + data.message);&#10;                }&#10;            }&#10;        }&#10;    });&#10;}&#10;&#10;function onListening() {&#10;    console.log('Server: Listening for socket connection requests.');&#10;}&#10;&#10;/** Executes when a connection has been establised.&lt;br&gt;&#10; *  Triggers an output on &lt;code&gt;'connection'&lt;/code&gt;.&#10; *  Adds an event listener to the socket. */&#10;function onConnection(socket) {&#10;   //socketID is the index of the socket in the sockets array. &#10;    var socketID = sockets.length;&#10;    console.log('Server: new socket established with ID: ' + socketID);&#10;    send('connection', {'socketID':socketID, 'status':'open'});&#10;    socket.on('message', function(message) {&#10;        send('received', {'socketID':socketID, 'message':message});&#10;    });&#10;    socket.on('close', function(message) {&#10;        send('connection', {'socketID':socketID, 'status':'closed'});&#10;    });&#10;    socket.on('error', function(message) {&#10;        error(message);&#10;    });&#10;&#10;    sockets.push(socket);    &#10;}&#10;&#10;/** Removes all inputHandlers from sockets.&lt;br&gt;&#10; * Unregisters event listeners from sockets.&lt;br&gt;&#10; * Closes server. */&#10;exports.wrapup = function(){&#10;    for (var i = 0; i &lt; sockets.length; i++) {&#10;        sockets[i].removeAllListeners();&#10;    }&#10;&#10;    sockets = [];&#10;    removeInputHandler(handle); &#10;&#10;    if (server != null) {&#10;        server.removeAllListeners();&#10;        server.close();&#10;        server = null;&#10;    }&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="http://terraswarm.org/accessors/net/WebSocketServer.js">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[880.0, 1095.0]">
        </property>
        <property name="hostInterface" class="ptolemy.data.expr.Parameter" value="0.0.0.0">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="8089">
        </property>
        <property name="receiveType" class="ptolemy.data.expr.Parameter" value="application/json">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="sendType" class="ptolemy.data.expr.Parameter" value="application/json">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="maxFrameSize" class="ptolemy.data.expr.Parameter" value="65536">
        </property>
        <port name="error" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="connection" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="MicrostepDelay5" class="ptolemy.actor.lib.MicrostepDelay">
        <property name="_location" class="ptolemy.kernel.util.Location" value="[630.0, 1135.0]">
        </property>
        <property name="_hideName" class="ptolemy.data.expr.SingletonParameter" value="true">
        </property>
        <property name="_flipPortsHorizontal" class="ptolemy.data.expr.Parameter" value="true">
        </property>
    </entity>
    <entity name="WebSocketServer5" class="org.terraswarm.accessor.JSAccessor">
        <display name="RobotBatteryServer"/>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor starts a server that listens for web socket&#10; *  connection requests on the specified hostInterface and port.  The&#10; *  hostInterface is needed only if the host machine has more than one&#10; *  network interface (e.g. Ethernet and WiFi) and 'localhost' does&#10; *  not resolve to the desired interface.&#10; *&#10; *  The output `connection` reports the when a&#10; *  connection is opened or closed.&#10; *&#10; *  When a message arrives on a connection, a `received`&#10; *  output is produced with that message. The maxFrameSize parameter limits the size&#10; *  of received messages, and any attempt to send to this client a larger message&#10; *  will cause an error.&#10; *&#10; *  When an input arrives on `toSend`, then a message is&#10; *  sent to one or all of the open socket connections.&#10; *&#10; *  When `wrapup()` is invoked, this accessor closes the&#10; *  server and all connections.&#10; *&#10; *  The default type for both sending and receiving&#10; *  is 'application/json', which allows sending and receiving anything that has&#10; *  a string representation in JSON. The types supported by this implementation&#10; *  include at least:&#10; *  * __application/json__: The send() function uses JSON.stringify() and sends the&#10; *    result with a UTF-8 encoding. An incoming byte stream will be parsed as JSON,&#10; *    and if the parsing fails, will be provided as a string interpretation of the byte&#10; *    stream.&#10; *  * __text/\*__: Any text type is sent as a string encoded in UTF-8.&#10; *  * __image/x__: Where __x__ is one of __json__, __png__, __gif__,&#10; *    and more.&#10; *    In this case, the data passed to send() is assumed to be an image, as encoded&#10; *    on the host, and the image will be encoded as a byte stream in the specified&#10; *    format before sending.  A received byte stream will be decoded as an image,&#10; *    if possible.&#10; *&#10; *  This accessor requires the module webSocket.&#10; *&#10; *  @accessor net/WebSocketServer&#10; *  @parameter {string} hostInterface The IP address or domain name of the&#10; *    network interface to listen to.&#10; *  @parameter {int} port The port to listen to for connections.&#10; *  @parameter {string} receiveType The MIME type for incoming messages, which defaults to 'application/json'.&#10; *  @parameter {string} sendType The MIME type for outgoing messages, which defaults to 'application/json'.&#10; *  @parameter {int} maxFrameSize The maximum frame size for a received message (default is 65536).&#10; *  @input toSend The data to be sent to open sockets. If this is an object with 'socketID' field and a 'message' field, then send the value of the message field to the socket identified by the socketID field. If the input has any other form, then the message is broadcast to all open socket connections.&#10; *  @output connection An output produced when a connection opens or closes. The output is an object with two fields, a 'socketID', which is a unique ID for this client connection, and a 'status' field, which is the string 'open' or 'closed'.&#10; *  @output received A message received a client in the form of an object with two fields, a 'socketID', which is a unique ID for this client connection, and a 'message' field, which is the message received from the client.&#10; *  @author Hokeun Kim, Edward Lee &#10; *  @version $$Id: WebSocketServer.js 282 2015-08-28 19:04:40Z eal $$ &#10; */&#10;&#10;var WebSocket = require('webSocket');&#10;var server = null;&#10;var running = false;&#10;&#10;/** Sets up the accessor by defining inputs and outputs. */&#10;exports.setup = function() {&#10;    parameter('hostInterface', {&#10;        value: &quot;localhost&quot;, &#10;        type: &quot;string&quot; &#10;    });&#10;    parameter('port', {&#10;        value: 8080, &#10;        type: &quot;int&quot; &#10;    });&#10;    parameter('receiveType', {&#10;        type : 'string',&#10;        value : 'application/json'&#10;    });&#10;    parameter('sendType', {&#10;        type : 'string',&#10;        value : 'application/json'&#10;    });&#10;    parameter('maxFrameSize', {&#10;        value: 65536, &#10;        type: &quot;int&quot; &#10;    });&#10;    input('toSend');&#10;    output('received');&#10;    output('connection');&#10;}&#10;&#10;var handle;&#10;var sockets = [];&#10;&#10;/** Starts the web socket and attaches functions to inputs and outputs. &#10;  * Adds an input handler on toSend that sends the input received to the right socket. */ &#10;exports.initialize = function() {&#10;    if (!server) {&#10;        server = new WebSocket.Server({&#10;                'port':getParameter('port'),&#10;                'hostInterface':getParameter('hostInterface'),&#10;                'receiveType':getParameter('receiveType'),&#10;                'sendType':getParameter('sendType'),&#10;                'maxFrameSize':getParameter('maxFrameSize')&#10;        });&#10;        server.on('listening', onListening);&#10;        server.on('connection', onConnection);&#10;        server.on('error', function (message) {&#10;            error(message);&#10;        });&#10;        server.start();&#10;    }&#10;    running = true;&#10;&#10;    handle = addInputHandler('toSend', function() {&#10;        var data = get('toSend');&#10;        // Careful: Don't do if (data) because if data === 0, then data is false.&#10;        if (data !== null) {&#10;            if ((data.socketID != null)  &amp;&amp; (data.message != null)) {&#10;                // data has the right form for a point-to-point send.&#10;                if (sockets[data.socketID] &amp;&amp; sockets[data.socketID].isOpen()) {&#10;                    // id matches this socket.&#10;                    console.log(&quot;Sending to socket id &quot; &#10;                            + data.socketID&#10;                            + &quot; message: &quot;&#10;                            + data.message);&#10;                    sockets[data.socketID].send(data.message);&#10;                } else {&#10;                    console.log('Socket with ID ' + data.socketID&#10;                            + ' is not open. Discarding message: ' + data.message);&#10;                }&#10;            } else {&#10;                // No socketID or message, so this is a broadcast message.&#10;                var success = false;&#10;                for (var id = 0; id &lt; sockets.length; id++) {&#10;                    if (sockets[id].isOpen()) {&#10;                        console.log(&quot;Broadcasting to socket id &quot; + id &#10;                                + &quot; message: &quot; + data);&#10;                        sockets[id].send(data);&#10;                        success = true;&#10;                    }&#10;                }&#10;                if (!success) {&#10;                    console.log('No open sockets. Discarding message: ' + data.message);&#10;                }&#10;            }&#10;        }&#10;    });&#10;}&#10;&#10;function onListening() {&#10;    console.log('Server: Listening for socket connection requests.');&#10;}&#10;&#10;/** Executes when a connection has been establised.&lt;br&gt;&#10; *  Triggers an output on &lt;code&gt;'connection'&lt;/code&gt;.&#10; *  Adds an event listener to the socket. */&#10;function onConnection(socket) {&#10;   //socketID is the index of the socket in the sockets array. &#10;    var socketID = sockets.length;&#10;    console.log('Server: new socket established with ID: ' + socketID);&#10;    send('connection', {'socketID':socketID, 'status':'open'});&#10;    socket.on('message', function(message) {&#10;        send('received', {'socketID':socketID, 'message':message});&#10;    });&#10;    socket.on('close', function(message) {&#10;        send('connection', {'socketID':socketID, 'status':'closed'});&#10;    });&#10;    socket.on('error', function(message) {&#10;        error(message);&#10;    });&#10;&#10;    sockets.push(socket);    &#10;}&#10;&#10;/** Removes all inputHandlers from sockets.&lt;br&gt;&#10; * Unregisters event listeners from sockets.&lt;br&gt;&#10; * Closes server. */&#10;exports.wrapup = function(){&#10;    for (var i = 0; i &lt; sockets.length; i++) {&#10;        sockets[i].removeAllListeners();&#10;    }&#10;&#10;    sockets = [];&#10;    removeInputHandler(handle); &#10;&#10;    if (server != null) {&#10;        server.removeAllListeners();&#10;        server.close();&#10;        server = null;&#10;    }&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="http://terraswarm.org/accessors/net/WebSocketServer.js">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[1590.0, 665.0]">
        </property>
        <property name="hostInterface" class="ptolemy.data.expr.Parameter" value="localhost">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="8090">
        </property>
        <property name="receiveType" class="ptolemy.data.expr.Parameter" value="application/json">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="sendType" class="ptolemy.data.expr.Parameter" value="application/json">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="maxFrameSize" class="ptolemy.data.expr.Parameter" value="65536">
        </property>
        <port name="error" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="connection" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="WebSocketServer2" class="org.terraswarm.accessor.JSAccessor">
        <display name="ALPS Receiver"/>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor starts a server that listens for web socket&#10; *  connection requests on the specified hostInterface and port.  The&#10; *  hostInterface is needed only if the host machine has more than one&#10; *  network interface (e.g. Ethernet and WiFi) and 'localhost' does&#10; *  not resolve to the desired interface.&#10; *&#10; *  &lt;p&gt;The output &lt;code&gt;connection&lt;/code&gt; reports the when a&#10; *  connection is opened or closed.&lt;/p&gt;&#10; *&#10; *  &lt;p&gt;When a message arrives on a connection, a &lt;code&gt;received&lt;/code&gt;&#10; *  output is produced with that message.&lt;/p&gt;&#10; *&#10; *  &lt;p&gt;When an input arrives on &lt;code&gt;toSend&lt;/code&gt;, then a message is&#10; *  sent to one or all of the open socket connections.&lt;/p&gt;&#10; *&#10; *  &lt;p&gt;When &lt;code&gt;wrapup()&lt;/code&gt; is invoked, this accessor closes the&#10; *  server and all connections.&lt;/p&gt;&#10; *&#10; *  &lt;p&gt;The messages can be any type that has a JSON representation.&#10; *  For incomming messages, this accessor assumes that the message is&#10; *  a string in UTF-8 that encodes a JSON object.&lt;/p&gt;&#10; *&#10; *  &lt;p&gt;This accessor requires the module webSocket.&lt;/p&gt;&#10; *&#10; *  @accessor WebSocketServer&#10; *  @parameter {string} hostInterface The IP address or domain name of the&#10; *    network interface to listen to.&#10; *  @parameter {number} port The port to listen to for connections.&#10; *  @input toSend The data to be sent to open sockets. If this is an object with 'socketID' field and a 'message' field, then send the value of the message field to the socket identified by the socketID field. If the input has any other form, then the message is broadcast to all open socket connections.&#10; *  @output connection An output produced when a connection opens or closes. The output is an object with two fields, a 'socketID', which is a unique ID for this client connection, and a 'status' field, which is the string 'open' or 'closed'.&#10; *  @output received A message received a client in the form of an object with two fields, a 'socketID', which is a unique ID for this client connection, and a 'message' field, which is the message received from the client.&#10; *  @author Hokeun Kim, Edward Lee &#10; *  @version $$Id: WebSocketServer.js 234 2015-08-01 22:06:40Z eal $$ &#10; */&#10;&#10;var WebSocket = require('webSocket');&#10;var server = null;&#10;var running = false;&#10;&#10;/** Sets up the accessor by defining inputs and outputs. */&#10;exports.setup = function() {&#10;    parameter('hostInterface', {&#10;        value: &quot;localhost&quot;, &#10;        type: &quot;string&quot; &#10;    });&#10;    parameter('port', {&#10;        value: 8080, &#10;        type: &quot;int&quot; &#10;    });&#10;    input('toSend');&#10;    output('received');&#10;    output('connection');&#10;}&#10;&#10;var handle;&#10;var sockets = [];&#10;&#10;/** Starts the web socket and attaches functions to inputs and outputs. &#10;  * Adds an input handler on toSend that sends the input received to the right socket. */ &#10;exports.initialize = function() {&#10;    if (!server) {&#10;        server = new WebSocket.Server({'port':getParameter('port'),&#10;                                       'hostInterface':getParameter('hostInterface')});&#10;        server.on('listening', onListening);&#10;        server.on('connection', onConnection);&#10;        server.start();&#10;    }&#10;    running = true;&#10;&#10;    handle = addInputHandler('toSend', function() {&#10;        var data = get('toSend');&#10;        // Careful: Don't do if (data) because if data === 0, then data is false.&#10;        if (data !== null) {&#10;            if ((data.socketID != null)  &amp;&amp; (data.message != null)) {&#10;                // data has the right form for a point-to-point send.&#10;                if (sockets[data.socketID] &amp;&amp; sockets[data.socketID].isOpen()) {&#10;                    // id matches this socket.&#10;                    console.log(&quot;Sending to socket id &quot; &#10;                            + data.socketID&#10;                            + &quot; message: &quot;&#10;                            + data.message);&#10;                    sockets[data.socketID].send(data.message);&#10;                } else {&#10;                    console.log('Socket with ID ' + data.socketID&#10;                            + ' is not open. Discarding message: ' + data.message);&#10;                }&#10;            } else {&#10;                // No socketID or message, so this is a broadcast message.&#10;                var success = false;&#10;                for (var id = 0; id &lt; sockets.length; id++) {&#10;                    if (sockets[id].isOpen()) {&#10;                        console.log(&quot;Broadcasting to socket id &quot; + id &#10;                                + &quot; message: &quot; + data);&#10;                        sockets[id].send(data);&#10;                        success = true;&#10;                    }&#10;                }&#10;                if (!success) {&#10;                    console.log('No open sockets. Discarding message: ' + data.message);&#10;                }&#10;            }&#10;        }&#10;    });&#10;}&#10;&#10;function onListening() {&#10;    console.log('Server: Listening for socket connection requests.');&#10;}&#10;&#10;/** Executes when a connection has been establised.&lt;br&gt;&#10; *  Triggers an output on &lt;code&gt;'connection'&lt;/code&gt;.&#10; *  Adds an event listener to the socket. */&#10;function onConnection(socket) {&#10;   //socketID is the index of the socket in the sockets array. &#10;    var socketID = sockets.length;&#10;    console.log('Server: new socket established with ID: ' + socketID);&#10;    send('connection', {'socketID':socketID, 'status':'open'});&#10;    socket.on('message', function(message) {&#10;        send('received', {'socketID':socketID, 'message':message});&#10;    });&#10;    socket.on('close', function(message) {&#10;        send('connection', {'socketID':socketID, 'status':'closed'});&#10;    });&#10;&#10;    sockets.push(socket);    &#10;}&#10;&#10;/** Removes all inputHandlers from sockets.&lt;br&gt;&#10; * Unregisters event listeners from sockets.&lt;br&gt;&#10; * Closes server. */&#10;exports.wrapup = function(){&#10;    for (var i = 0; i &lt; sockets.length; i++) {&#10;        sockets[i].removeAllListeners();&#10;    }&#10;&#10;    sockets = [];&#10;    removeInputHandler(handle); &#10;&#10;    if (server != null) {&#10;        server.removeAllListeners();&#10;        server.close();&#10;        server = null;&#10;    }&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="http://terraswarm.org/accessors/net/WebSocketServer.js">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="JSAccessorIcon" class="ptolemy.vergil.icon.EditorIcon">
            <property name="rectangle" class="ptolemy.vergil.kernel.attributes.RectangleAttribute">
                <property name="_location" class="ptolemy.kernel.util.Location" value="[-38.0, -29.0]">
                </property>
                <property name="width" class="ptolemy.data.expr.Parameter" value="74.0">
                </property>
                <property name="height" class="ptolemy.data.expr.Parameter" value="64.0">
                </property>
                <property name="fillColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.6,0.8,1.0,1.0}">
                </property>
            </property>
            <property name="Annotation" class="ptolemy.vergil.kernel.attributes.TextAttribute">
                <property name="textSize" class="ptolemy.data.expr.Parameter" value="30">
                </property>
                <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0,0.0,0.0,1.0}">
                </property>
                <property name="bold" class="ptolemy.data.expr.Parameter" value="false">
                </property>
                <property name="italic" class="ptolemy.data.expr.Parameter" value="false">
                </property>
                <property name="text" class="ptolemy.kernel.util.StringAttribute" value="WS">
                </property>
                <property name="_location" class="ptolemy.kernel.util.Location" value="[-17.0, -12.0]">
                </property>
            </property>
            <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={281, 257, 934, 634}, maximized=false}">
            </property>
            <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[700, 524]">
            </property>
            <property name="polygon" class="ptolemy.vergil.kernel.attributes.ResizablePolygonAttribute">
                <property name="_location" class="ptolemy.kernel.util.Location" value="{-25.0, 3.0}">
                </property>
                <property name="lineWidth" class="ptolemy.data.expr.Parameter" value="0">
                </property>
                <property name="width" class="ptolemy.data.expr.Parameter" value="14.0">
                </property>
                <property name="height" class="ptolemy.data.expr.Parameter" value="60.99999999999999">
                </property>
                <property name="centered" class="ptolemy.data.expr.Parameter" value="true">
                </property>
                <property name="fillColor" class="ptolemy.actor.gui.ColorAttribute" value="{1.0, 1.0, 1.0, 1.0}">
                </property>
                <property name="vertices" class="ptolemy.data.expr.Parameter" value="{0.0, 0.0, 10.0, -10.0, 0.0, -20.0}">
                </property>
                <property name="_renderLast" class="ptolemy.kernel.util.SingletonAttribute">
                </property>
            </property>
            <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="4.0">
            </property>
            <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{0.0, 0.0}">
            </property>
        </property>
        <property name="hostInterface" class="ptolemy.data.expr.Parameter" value="0.0.0.0">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="8082">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[180.0, 550.0]">
        </property>
        <port name="error" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="false">
            </property>
        </port>
        <port name="connection" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="Display6" class="ptolemy.actor.lib.gui.Display">
        <display name="Connections"/>
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={285, 662, 759, 306}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[759, 262]">
        </property>
        <property name="title" class="ptolemy.data.expr.StringParameter" value="Connection Commands">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[870.0, 835.0]">
        </property>
    </entity>
    <entity name="WebSocketServer3" class="org.terraswarm.accessor.JSAccessor">
        <display name="ALPS Receiver"/>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2014-2015 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor starts a server that listens for web socket&#10; *  connection requests on the specified hostInterface and port.  The&#10; *  hostInterface is needed only if the host machine has more than one&#10; *  network interface (e.g. Ethernet and WiFi) and 'localhost' does&#10; *  not resolve to the desired interface.&#10; *&#10; *  &lt;p&gt;The output &lt;code&gt;connection&lt;/code&gt; reports the when a&#10; *  connection is opened or closed.&lt;/p&gt;&#10; *&#10; *  &lt;p&gt;When a message arrives on a connection, a &lt;code&gt;received&lt;/code&gt;&#10; *  output is produced with that message.&lt;/p&gt;&#10; *&#10; *  &lt;p&gt;When an input arrives on &lt;code&gt;toSend&lt;/code&gt;, then a message is&#10; *  sent to one or all of the open socket connections.&lt;/p&gt;&#10; *&#10; *  &lt;p&gt;When &lt;code&gt;wrapup()&lt;/code&gt; is invoked, this accessor closes the&#10; *  server and all connections.&lt;/p&gt;&#10; *&#10; *  &lt;p&gt;The messages can be any type that has a JSON representation.&#10; *  For incomming messages, this accessor assumes that the message is&#10; *  a string in UTF-8 that encodes a JSON object.&lt;/p&gt;&#10; *&#10; *  &lt;p&gt;This accessor requires the module webSocket.&lt;/p&gt;&#10; *&#10; *  @accessor WebSocketServer&#10; *  @parameter {string} hostInterface The IP address or domain name of the&#10; *    network interface to listen to.&#10; *  @parameter {number} port The port to listen to for connections.&#10; *  @input toSend The data to be sent to open sockets. If this is an object with 'socketID' field and a 'message' field, then send the value of the message field to the socket identified by the socketID field. If the input has any other form, then the message is broadcast to all open socket connections.&#10; *  @output connection An output produced when a connection opens or closes. The output is an object with two fields, a 'socketID', which is a unique ID for this client connection, and a 'status' field, which is the string 'open' or 'closed'.&#10; *  @output received A message received a client in the form of an object with two fields, a 'socketID', which is a unique ID for this client connection, and a 'message' field, which is the message received from the client.&#10; *  @author Hokeun Kim, Edward Lee &#10; *  @version $$Id: WebSocketServer.js 234 2015-08-01 22:06:40Z eal $$ &#10; */&#10;&#10;var WebSocket = require('webSocket');&#10;var server = null;&#10;var running = false;&#10;&#10;/** Sets up the accessor by defining inputs and outputs. */&#10;exports.setup = function() {&#10;    parameter('hostInterface', {&#10;        value: &quot;localhost&quot;, &#10;        type: &quot;string&quot; &#10;    });&#10;    parameter('port', {&#10;        value: 8080, &#10;        type: &quot;int&quot; &#10;    });&#10;    input('toSend');&#10;    output('received');&#10;    output('connection');&#10;}&#10;&#10;var handle;&#10;var sockets = [];&#10;&#10;/** Starts the web socket and attaches functions to inputs and outputs. &#10;  * Adds an input handler on toSend that sends the input received to the right socket. */ &#10;exports.initialize = function() {&#10;    if (!server) {&#10;        server = new WebSocket.Server({'port':getParameter('port'),&#10;                                       'hostInterface':getParameter('hostInterface')});&#10;        server.on('listening', onListening);&#10;        server.on('connection', onConnection);&#10;        server.start();&#10;    }&#10;    running = true;&#10;&#10;    handle = addInputHandler('toSend', function() {&#10;        var data = get('toSend');&#10;        // Careful: Don't do if (data) because if data === 0, then data is false.&#10;        if (data !== null) {&#10;            if ((data.socketID != null)  &amp;&amp; (data.message != null)) {&#10;                // data has the right form for a point-to-point send.&#10;                if (sockets[data.socketID] &amp;&amp; sockets[data.socketID].isOpen()) {&#10;                    // id matches this socket.&#10;                    console.log(&quot;Sending to socket id &quot; &#10;                            + data.socketID&#10;                            + &quot; message: &quot;&#10;                            + data.message);&#10;                    sockets[data.socketID].send(data.message);&#10;                } else {&#10;                    console.log('Socket with ID ' + data.socketID&#10;                            + ' is not open. Discarding message: ' + data.message);&#10;                }&#10;            } else {&#10;                // No socketID or message, so this is a broadcast message.&#10;                var success = false;&#10;                for (var id = 0; id &lt; sockets.length; id++) {&#10;                    if (sockets[id].isOpen()) {&#10;                        console.log(&quot;Broadcasting to socket id &quot; + id &#10;                                + &quot; message: &quot; + data);&#10;                        sockets[id].send(data);&#10;                        success = true;&#10;                    }&#10;                }&#10;                if (!success) {&#10;                    console.log('No open sockets. Discarding message: ' + data.message);&#10;                }&#10;            }&#10;        }&#10;    });&#10;}&#10;&#10;function onListening() {&#10;    console.log('Server: Listening for socket connection requests.');&#10;}&#10;&#10;/** Executes when a connection has been establised.&lt;br&gt;&#10; *  Triggers an output on &lt;code&gt;'connection'&lt;/code&gt;.&#10; *  Adds an event listener to the socket. */&#10;function onConnection(socket) {&#10;   //socketID is the index of the socket in the sockets array. &#10;    var socketID = sockets.length;&#10;    console.log('Server: new socket established with ID: ' + socketID);&#10;    send('connection', {'socketID':socketID, 'status':'open'});&#10;    socket.on('message', function(message) {&#10;        send('received', {'socketID':socketID, 'message':message});&#10;    });&#10;    socket.on('close', function(message) {&#10;        send('connection', {'socketID':socketID, 'status':'closed'});&#10;    });&#10;&#10;    sockets.push(socket);    &#10;}&#10;&#10;/** Removes all inputHandlers from sockets.&lt;br&gt;&#10; * Unregisters event listeners from sockets.&lt;br&gt;&#10; * Closes server. */&#10;exports.wrapup = function(){&#10;    for (var i = 0; i &lt; sockets.length; i++) {&#10;        sockets[i].removeAllListeners();&#10;    }&#10;&#10;    sockets = [];&#10;    removeInputHandler(handle); &#10;&#10;    if (server != null) {&#10;        server.removeAllListeners();&#10;        server.close();&#10;        server = null;&#10;    }&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="http://terraswarm.org/accessors/net/WebSocketServer.js">
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="JSAccessorIcon" class="ptolemy.vergil.icon.EditorIcon">
            <property name="rectangle" class="ptolemy.vergil.kernel.attributes.RectangleAttribute">
                <property name="_location" class="ptolemy.kernel.util.Location" value="[-38.0, -29.0]">
                </property>
                <property name="width" class="ptolemy.data.expr.Parameter" value="74.0">
                </property>
                <property name="height" class="ptolemy.data.expr.Parameter" value="64.0">
                </property>
                <property name="fillColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.6,0.8,1.0,1.0}">
                </property>
            </property>
            <property name="Annotation" class="ptolemy.vergil.kernel.attributes.TextAttribute">
                <property name="textSize" class="ptolemy.data.expr.Parameter" value="30">
                </property>
                <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0,0.0,0.0,1.0}">
                </property>
                <property name="bold" class="ptolemy.data.expr.Parameter" value="false">
                </property>
                <property name="italic" class="ptolemy.data.expr.Parameter" value="false">
                </property>
                <property name="text" class="ptolemy.kernel.util.StringAttribute" value="WS">
                </property>
                <property name="_location" class="ptolemy.kernel.util.Location" value="[-17.0, -12.0]">
                </property>
            </property>
            <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={281, 257, 934, 634}, maximized=false}">
            </property>
            <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[700, 524]">
            </property>
            <property name="polygon" class="ptolemy.vergil.kernel.attributes.ResizablePolygonAttribute">
                <property name="_location" class="ptolemy.kernel.util.Location" value="{-25.0, 3.0}">
                </property>
                <property name="lineWidth" class="ptolemy.data.expr.Parameter" value="0">
                </property>
                <property name="width" class="ptolemy.data.expr.Parameter" value="14.0">
                </property>
                <property name="height" class="ptolemy.data.expr.Parameter" value="60.99999999999999">
                </property>
                <property name="centered" class="ptolemy.data.expr.Parameter" value="true">
                </property>
                <property name="fillColor" class="ptolemy.actor.gui.ColorAttribute" value="{1.0, 1.0, 1.0, 1.0}">
                </property>
                <property name="vertices" class="ptolemy.data.expr.Parameter" value="{0.0, 0.0, 10.0, -10.0, 0.0, -20.0}">
                </property>
                <property name="_renderLast" class="ptolemy.kernel.util.SingletonAttribute">
                </property>
            </property>
            <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="4.0">
            </property>
            <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{0.0, 0.0}">
            </property>
        </property>
        <property name="hostInterface" class="ptolemy.data.expr.Parameter" value="0.0.0.0">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="30005">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[185.0, 765.0]">
        </property>
        <port name="error" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="toSend" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="received" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="false">
            </property>
        </port>
        <port name="connection" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_hide" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="Display" class="ptolemy.actor.lib.gui.Display">
        <display name="User Choices"/>
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={72, 522, 761, 312}, maximized=false}">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute" value="[759, 262]">
        </property>
        <property name="title" class="ptolemy.data.expr.StringParameter" value="app">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[595.0, 1205.0]">
        </property>
    </entity>
    <relation name="relation16" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[575.0, 1085.0]">
        </vertex>
    </relation>
    <relation name="relation" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation42" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation17" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[830.0, 835.0]">
        </vertex>
    </relation>
    <relation name="relation30" class="ptolemy.actor.TypedIORelation">
        <vertex name="vertex1" value="[1515.0, 665.0]">
        </vertex>
    </relation>
    <relation name="relation37" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[245.0, 550.0]">
        </vertex>
    </relation>
    <relation name="relation2" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[520.0, 1145.0]">
        </vertex>
    </relation>
    <link port="WebSocketServer.toSend" relation="relation2"/>
    <link port="WebSocketServer.received" relation="relation16"/>
    <link port="RoboCafeController.UserChoice" relation="relation16"/>
    <link port="RoboCafeController.SelectPhoneRobot" relation="relation17"/>
    <link port="RoboCafeController.RobotStatus" relation="relation"/>
    <link port="RoboCafeController.AppState" relation="relation42"/>
    <link port="Display7.input" relation="relation16"/>
    <link port="WebSocketServer4.toSend" relation="relation"/>
    <link port="MicrostepDelay5.input" relation="relation42"/>
    <link port="MicrostepDelay5.output" relation="relation2"/>
    <link port="WebSocketServer5.toSend" relation="relation30"/>
    <link port="WebSocketServer2.received" relation="relation37"/>
    <link port="Display6.input" relation="relation17"/>
    <link port="Display.input" relation="relation2"/>
</entity>
